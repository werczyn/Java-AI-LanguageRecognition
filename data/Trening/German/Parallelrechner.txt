Problemstellungen, bei denen größere Datenmengen in mehreren aufeinander folgenden Schritten verarbeitet werden, sogenanntes Pipelining. Z. B. lassen sich die Module eines Compilers (Präprozessor, lexikalische Analyse, semantische Analyse, Optimierung, Codeerzeugung), als parallel laufende Prozesse realisieren.
Jeder Prozess reicht seine Ausgabe dabei an den nachfolgenden Prozess weiter und ist damit frei um die nächsten Daten zu verarbeiten, während der nachfolgende Prozessschritt von einem anderen Prozess erledigt wird. Dabei kann jeder der Prozesse jeweils einem Prozessor zugewiesen werden, so dass eine weitgehende echte Parallelisierung der Verarbeitung erreicht wird.
Problemstellungen dieser Art sind in der Regel für Rechner geeignet, die über vergleichsweise wenige Prozessoren verfügen.
Man spricht in diesem Fall häufig von Multithreading oder Nebenläufigkeit. Allerdings ist für Multithreading (Thread = Faden) nicht zwingend erforderlich, dass die verschiedenen Prozesse (Threads) jeweils auf einem eigenen Prozessor laufen. Denkbar wäre ebenso, die verschiedenen Prozesse Quasi parallel auf einem einzigen Prozessor laufen zu lassen. Allerdings können dann die Geschwindigkeitsvorteile nicht realisiert werden.