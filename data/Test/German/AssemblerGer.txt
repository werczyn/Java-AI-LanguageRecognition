Immer mehr an maschinennaher Programmierung – die Domäne von Assemblersprache – kann heute fast vollständig durch höhere Programmiersprachen abgedeckt werden. Auch steht der Möglichkeit der Erstellung effizienter Programme die erschwerte Wartbarkeit von Assemblerprogrammen gegenüber. Für optimalen Code wird immer mehr Kontextwissen benötigt (zum Beispiel: Cachenutzung, Lokalität, temporale Nutzung etc.). Ein Beispiel hierfür wäre der SSE-Befehl movntq, welcher wegen fehlenden Kontextwissens nicht oder nur sehr spekulativ von Compilern eingesetzt werden kann. Auf der anderen Seite benutzen die meisten Compiler für höhere Programmiersprachen nur einen kleinen Teil des Befehlssatzes der CPU (ein Sachverhalt, der zur Entwicklung von RISC-Prozessoren geführt hat), während dem Assemblerprogrammierer der vollständige Befehlssatz zur Verfügung steht, sodass er in manchen Situationen effizientere Befehle benutzen kann, die dem reinen Hochsprachenprogrammierer nicht zugänglich sind. Einige Programmiersysteme für höhere Programmiersprachen gestatten es, Assemblersprachenbefehle mittels Inline-Assembler in den Quelltext zu integrieren. Die Anwendung kann sich dann auf die Situationen beschränken, in denen es aus funktionalen oder Effizienzgründen notwendig oder nützlich ist, maschinennah zu programmieren. Zu beachten ist, dass verschiedene Prozessorarchitekturen grundverschiedene Assembler- und Maschinensprachen haben, so dass jeweils ein zur aktuellen Architektur passender Assembler benötigt wird und die Programme nicht oder nur unter großen Einschränkungen portabel sind. Makroassembler gestatten die Bildung von parametrisierbaren Anweisungen. Eine Makroanweisung wird im Allgemeinen in mehr als einen Maschinenbefehl umgesetzt.